/**
 * Auto-generated source file for EchoService
 * Generated from /home/zhaodi-chen/project/uvrpc/examples/echo_service.yaml
 * Do not edit this file manually
 */

#include "echoservice_gen.h"
#include <mpack.h>
#include <stdlib.h>
#include <string.h>

#define UVRPC_UNUSED __attribute__((unused))


/* ==================== echo Request ==================== */

UVRPC_UNUSED int EchoService_echo_SerializeRequest(
    const EchoService_echo_Request_t* request,
    uint8_t** output,
    size_t* output_size
) {
    if (!request || !output || !output_size) {
        return -1;
    }

    char buffer[4096];
    mpack_writer_t writer;
    mpack_writer_init(&writer, buffer, sizeof(buffer));

    mpack_start_map(&writer, 1);

    /* message */
    mpack_write_cstr(&writer, "message");
    if (request->message) {
        mpack_write_cstr(&writer, request->message);
    } else {
        mpack_write_nil(&writer);
    }

    mpack_finish_map(&writer);

    if (mpack_writer_error(&writer) != mpack_ok) {
        return -1;
    }

    size_t size = mpack_writer_buffer_used(&writer);
    *output = (uint8_t*)malloc(size);
    if (!*output) {
        return -1;
    }

    memcpy(*output, buffer, size);
    *output_size = size;

    return 0;
}

UVRPC_UNUSED int EchoService_echo_DeserializeRequest(
    const uint8_t* data,
    size_t size,
    EchoService_echo_Request_t* request
) {
    if (!data || !request) {
        return -1;
    }

    memset(request, 0, sizeof(EchoService_echo_Request_t));

    mpack_reader_t reader;
    mpack_reader_init_data(&reader, (const char*)data, size);

    uint32_t count = mpack_expect_map_max(&reader, 100);

    for (uint32_t i = count; i > 0 && mpack_reader_error(&reader) == mpack_ok; --i) {
        char key[128];
        mpack_expect_cstr(&reader, key, sizeof(key));

        if (strcmp(key, "message") == 0) {
            uint32_t len = mpack_expect_str(&reader);
            if (mpack_reader_error(&reader) == mpack_ok && len > 0) {
                const char* str = mpack_read_bytes_inplace(&reader, len);
                if (mpack_reader_error(&reader) == mpack_ok && str) {
                    request->message = strndup(str, len);
                }
                mpack_done_str(&reader);
            } else {
                mpack_discard(&reader);
            }
        }
    }

    mpack_done_map(&reader);

    if (mpack_reader_error(&reader) != mpack_ok) {
        EchoService_echo_FreeRequest(request);
        mpack_reader_destroy(&reader);
        return -1;
    }

    mpack_reader_destroy(&reader);
    return 0;
}

UVRPC_UNUSED void EchoService_echo_FreeRequest(
    EchoService_echo_Request_t* request
) {
    if (!request) {
        return;
    }

    if (request->message) {
        free(request->message);
        request->message = NULL;
    }
}

/* ==================== echo Response ==================== */

UVRPC_UNUSED int EchoService_echo_SerializeResponse(
    const EchoService_echo_Response_t* response,
    uint8_t** output,
    size_t* output_size
) {
    if (!response || !output || !output_size) {
        return -1;
    }

    char buffer[4096];
    mpack_writer_t writer;
    mpack_writer_init(&writer, buffer, sizeof(buffer));

    mpack_start_map(&writer, 2);

    /* echo */
    mpack_write_cstr(&writer, "echo");
    if (response->echo) {
        mpack_write_cstr(&writer, response->echo);
    } else {
        mpack_write_nil(&writer);
    }

    /* timestamp */
    mpack_write_cstr(&writer, "timestamp");
    mpack_write_int(&writer, response->timestamp);

    mpack_finish_map(&writer);

    if (mpack_writer_error(&writer) != mpack_ok) {
        return -1;
    }

    size_t size = mpack_writer_buffer_used(&writer);
    *output = (uint8_t*)malloc(size);
    if (!*output) {
        return -1;
    }

    memcpy(*output, buffer, size);
    *output_size = size;

    return 0;
}

UVRPC_UNUSED int EchoService_echo_DeserializeResponse(
    const uint8_t* data,
    size_t size,
    EchoService_echo_Response_t* response
) {
    if (!data || !response) {
        return -1;
    }

    memset(response, 0, sizeof(EchoService_echo_Response_t));

    mpack_reader_t reader;
    mpack_reader_init_data(&reader, (const char*)data, size);

    uint32_t count = mpack_expect_map_max(&reader, 100);

    for (uint32_t i = count; i > 0 && mpack_reader_error(&reader) == mpack_ok; --i) {
        char key[128];
        mpack_expect_cstr(&reader, key, sizeof(key));

        if (strcmp(key, "echo") == 0) {
            uint32_t len = mpack_expect_str(&reader);
            if (mpack_reader_error(&reader) == mpack_ok && len > 0) {
                const char* str = mpack_read_bytes_inplace(&reader, len);
                if (mpack_reader_error(&reader) == mpack_ok && str) {
                    response->echo = strndup(str, len);
                }
                mpack_done_str(&reader);
            } else {
                mpack_discard(&reader);
            }
        }
        if (strcmp(key, "timestamp") == 0) {
            response->timestamp = mpack_expect_int(&reader);
        }
    }

    mpack_done_map(&reader);

    if (mpack_reader_error(&reader) != mpack_ok) {
        EchoService_echo_FreeResponse(response);
        mpack_reader_destroy(&reader);
        return -1;
    }

    mpack_reader_destroy(&reader);
    return 0;
}

UVRPC_UNUSED void EchoService_echo_FreeResponse(
    EchoService_echo_Response_t* response
) {
    if (!response) {
        return;
    }

    if (response->echo) {
        free(response->echo);
        response->echo = NULL;
    }
}

/* ==================== add Request ==================== */

UVRPC_UNUSED int EchoService_add_SerializeRequest(
    const EchoService_add_Request_t* request,
    uint8_t** output,
    size_t* output_size
) {
    if (!request || !output || !output_size) {
        return -1;
    }

    char buffer[4096];
    mpack_writer_t writer;
    mpack_writer_init(&writer, buffer, sizeof(buffer));

    mpack_start_map(&writer, 2);

    /* a */
    mpack_write_cstr(&writer, "a");
    mpack_write_double(&writer, request->a);

    /* b */
    mpack_write_cstr(&writer, "b");
    mpack_write_double(&writer, request->b);

    mpack_finish_map(&writer);

    if (mpack_writer_error(&writer) != mpack_ok) {
        return -1;
    }

    size_t size = mpack_writer_buffer_used(&writer);
    *output = (uint8_t*)malloc(size);
    if (!*output) {
        return -1;
    }

    memcpy(*output, buffer, size);
    *output_size = size;

    return 0;
}

UVRPC_UNUSED int EchoService_add_DeserializeRequest(
    const uint8_t* data,
    size_t size,
    EchoService_add_Request_t* request
) {
    if (!data || !request) {
        return -1;
    }

    memset(request, 0, sizeof(EchoService_add_Request_t));

    mpack_reader_t reader;
    mpack_reader_init_data(&reader, (const char*)data, size);

    uint32_t count = mpack_expect_map_max(&reader, 100);

    for (uint32_t i = count; i > 0 && mpack_reader_error(&reader) == mpack_ok; --i) {
        char key[128];
        mpack_expect_cstr(&reader, key, sizeof(key));

        if (strcmp(key, "a") == 0) {
            request->a = mpack_expect_double(&reader);
        }
        if (strcmp(key, "b") == 0) {
            request->b = mpack_expect_double(&reader);
        }
    }

    mpack_done_map(&reader);

    if (mpack_reader_error(&reader) != mpack_ok) {
        EchoService_add_FreeRequest(request);
        mpack_reader_destroy(&reader);
        return -1;
    }

    mpack_reader_destroy(&reader);
    return 0;
}

UVRPC_UNUSED void EchoService_add_FreeRequest(
    EchoService_add_Request_t* request
) {
    if (!request) {
        return;
    }

}

/* ==================== add Response ==================== */

UVRPC_UNUSED int EchoService_add_SerializeResponse(
    const EchoService_add_Response_t* response,
    uint8_t** output,
    size_t* output_size
) {
    if (!response || !output || !output_size) {
        return -1;
    }

    char buffer[4096];
    mpack_writer_t writer;
    mpack_writer_init(&writer, buffer, sizeof(buffer));

    mpack_start_map(&writer, 1);

    /* result */
    mpack_write_cstr(&writer, "result");
    mpack_write_double(&writer, response->result);

    mpack_finish_map(&writer);

    if (mpack_writer_error(&writer) != mpack_ok) {
        return -1;
    }

    size_t size = mpack_writer_buffer_used(&writer);
    *output = (uint8_t*)malloc(size);
    if (!*output) {
        return -1;
    }

    memcpy(*output, buffer, size);
    *output_size = size;

    return 0;
}

UVRPC_UNUSED int EchoService_add_DeserializeResponse(
    const uint8_t* data,
    size_t size,
    EchoService_add_Response_t* response
) {
    if (!data || !response) {
        return -1;
    }

    memset(response, 0, sizeof(EchoService_add_Response_t));

    mpack_reader_t reader;
    mpack_reader_init_data(&reader, (const char*)data, size);

    uint32_t count = mpack_expect_map_max(&reader, 100);

    for (uint32_t i = count; i > 0 && mpack_reader_error(&reader) == mpack_ok; --i) {
        char key[128];
        mpack_expect_cstr(&reader, key, sizeof(key));

        if (strcmp(key, "result") == 0) {
            response->result = mpack_expect_double(&reader);
        }
    }

    mpack_done_map(&reader);

    if (mpack_reader_error(&reader) != mpack_ok) {
        EchoService_add_FreeResponse(response);
        mpack_reader_destroy(&reader);
        return -1;
    }

    mpack_reader_destroy(&reader);
    return 0;
}

UVRPC_UNUSED void EchoService_add_FreeResponse(
    EchoService_add_Response_t* response
) {
    if (!response) {
        return;
    }

}

/* ==================== get_info Request ==================== */

UVRPC_UNUSED int EchoService_getInfo_SerializeRequest(
    const EchoService_getInfo_Request_t* request,
    uint8_t** output,
    size_t* output_size
) {
    if (!request || !output || !output_size) {
        return -1;
    }

    char buffer[4096];
    mpack_writer_t writer;
    mpack_writer_init(&writer, buffer, sizeof(buffer));

    mpack_start_map(&writer, 0);

    mpack_finish_map(&writer);

    if (mpack_writer_error(&writer) != mpack_ok) {
        return -1;
    }

    size_t size = mpack_writer_buffer_used(&writer);
    *output = (uint8_t*)malloc(size);
    if (!*output) {
        return -1;
    }

    memcpy(*output, buffer, size);
    *output_size = size;

    return 0;
}

UVRPC_UNUSED int EchoService_getInfo_DeserializeRequest(
    const uint8_t* data,
    size_t size,
    EchoService_getInfo_Request_t* request
) {
    if (!data || !request) {
        return -1;
    }

    memset(request, 0, sizeof(EchoService_getInfo_Request_t));

    mpack_reader_t reader;
    mpack_reader_init_data(&reader, (const char*)data, size);

    uint32_t count = mpack_expect_map_max(&reader, 100);

    for (uint32_t i = count; i > 0 && mpack_reader_error(&reader) == mpack_ok; --i) {
        char key[128];
        mpack_expect_cstr(&reader, key, sizeof(key));

    }

    mpack_done_map(&reader);

    if (mpack_reader_error(&reader) != mpack_ok) {
        EchoService_getInfo_FreeRequest(request);
        mpack_reader_destroy(&reader);
        return -1;
    }

    mpack_reader_destroy(&reader);
    return 0;
}

UVRPC_UNUSED void EchoService_getInfo_FreeRequest(
    EchoService_getInfo_Request_t* request
) {
    if (!request) {
        return;
    }

    (void)request;  /* Avoid unused variable warning when no fields need freeing */
}

/* ==================== get_info Response ==================== */

UVRPC_UNUSED int EchoService_getInfo_SerializeResponse(
    const EchoService_getInfo_Response_t* response,
    uint8_t** output,
    size_t* output_size
) {
    if (!response || !output || !output_size) {
        return -1;
    }

    char buffer[4096];
    mpack_writer_t writer;
    mpack_writer_init(&writer, buffer, sizeof(buffer));

    mpack_start_map(&writer, 3);

    /* service */
    mpack_write_cstr(&writer, "service");
    if (response->service) {
        mpack_write_cstr(&writer, response->service);
    } else {
        mpack_write_nil(&writer);
    }

    /* version */
    mpack_write_cstr(&writer, "version");
    if (response->version) {
        mpack_write_cstr(&writer, response->version);
    } else {
        mpack_write_nil(&writer);
    }

    /* uptime */
    mpack_write_cstr(&writer, "uptime");
    mpack_write_int(&writer, response->uptime);

    mpack_finish_map(&writer);

    if (mpack_writer_error(&writer) != mpack_ok) {
        return -1;
    }

    size_t size = mpack_writer_buffer_used(&writer);
    *output = (uint8_t*)malloc(size);
    if (!*output) {
        return -1;
    }

    memcpy(*output, buffer, size);
    *output_size = size;

    return 0;
}

UVRPC_UNUSED int EchoService_getInfo_DeserializeResponse(
    const uint8_t* data,
    size_t size,
    EchoService_getInfo_Response_t* response
) {
    if (!data || !response) {
        return -1;
    }

    memset(response, 0, sizeof(EchoService_getInfo_Response_t));

    mpack_reader_t reader;
    mpack_reader_init_data(&reader, (const char*)data, size);

    uint32_t count = mpack_expect_map_max(&reader, 100);

    for (uint32_t i = count; i > 0 && mpack_reader_error(&reader) == mpack_ok; --i) {
        char key[128];
        mpack_expect_cstr(&reader, key, sizeof(key));

        if (strcmp(key, "service") == 0) {
            uint32_t len = mpack_expect_str(&reader);
            if (mpack_reader_error(&reader) == mpack_ok && len > 0) {
                const char* str = mpack_read_bytes_inplace(&reader, len);
                if (mpack_reader_error(&reader) == mpack_ok && str) {
                    response->service = strndup(str, len);
                }
                mpack_done_str(&reader);
            } else {
                mpack_discard(&reader);
            }
        }
        if (strcmp(key, "version") == 0) {
            uint32_t len = mpack_expect_str(&reader);
            if (mpack_reader_error(&reader) == mpack_ok && len > 0) {
                const char* str = mpack_read_bytes_inplace(&reader, len);
                if (mpack_reader_error(&reader) == mpack_ok && str) {
                    response->version = strndup(str, len);
                }
                mpack_done_str(&reader);
            } else {
                mpack_discard(&reader);
            }
        }
        if (strcmp(key, "uptime") == 0) {
            response->uptime = mpack_expect_int(&reader);
        }
    }

    mpack_done_map(&reader);

    if (mpack_reader_error(&reader) != mpack_ok) {
        EchoService_getInfo_FreeResponse(response);
        mpack_reader_destroy(&reader);
        return -1;
    }

    mpack_reader_destroy(&reader);
    return 0;
}

UVRPC_UNUSED void EchoService_getInfo_FreeResponse(
    EchoService_getInfo_Response_t* response
) {
    if (!response) {
        return;
    }

    if (response->service) {
        free(response->service);
        response->service = NULL;
    }
    if (response->version) {
        free(response->version);
        response->version = NULL;
    }
}
