/**
 * Auto-generated client source file for EchoService
 * Generated from /home/zhaodi-chen/project/uvrpc/examples/echo_service.yaml
 * Do not edit this file manually
 */

#include "echoservice_gen_client.h"
#include "echoservice_gen.h"
#include <stdlib.h>
#include <string.h>


/* ==================== echo Client API ==================== */

int EchoService_echo_Async(
    uvrpc_client_t* client,
    const EchoService_echo_Request_t* request,
    uvrpc_async_t* async
) {
    if (!client || !request || !async) {
        return UVRPC_ERROR_INVALID_PARAM;
    }

    /* Serialize request */
    uint8_t* serialized = NULL;
    size_t serialized_size = 0;
    if (EchoService_echo_SerializeRequest(request, &serialized, &serialized_size) != 0) {
        return UVRPC_ERROR;
    }

    /* Send async call */
    int rc = uvrpc_client_call_async(client, "EchoService.echo", "echo",
                                      serialized, serialized_size, async);
    
    /* Free serialized data (uvrpc_client_call_async takes ownership) */
    if (rc != UVRPC_OK) {
        free(serialized);
    }

    return rc;
}

int EchoService_echo_AsyncTimeout(
    uvrpc_client_t* client,
    const EchoService_echo_Request_t* request,
    uvrpc_async_t* async,
    uint64_t timeout_ms
) {
    (void)timeout_ms; /* Timeout is handled in uvrpc_async_await_timeout */
    return EchoService_echo_Async(client, request, async);
}

int EchoService_echo_Await(
    const uvrpc_async_result_t* result,
    EchoService_echo_Response_t* response
) {
    if (!result || !response) {
        return UVRPC_ERROR_INVALID_PARAM;
    }

    if (result->status != UVRPC_OK) {
        return result->status;
    }

    /* Deserialize response */
    if (EchoService_echo_DeserializeResponse(
            result->response_data, result->response_size, response) != 0) {
        return UVRPC_ERROR;
    }

    return UVRPC_OK;
}

int EchoService_echo_CallAsync(
    uvrpc_client_t* client,
    const EchoService_echo_Request_t* request,
    EchoService_echo_Response_t* response,
    uv_loop_t* loop
) {
    if (!client || !request || !response || !loop) {
        return UVRPC_ERROR_INVALID_PARAM;
    }

    /* Create async context */
    uvrpc_async_t* async = uvrpc_async_create(loop);
    if (!async) {
        return UVRPC_ERROR_NO_MEMORY;
    }

    /* Send async call */
    int rc = EchoService_echo_Async(client, request, async);
    if (rc != UVRPC_OK) {
        uvrpc_async_free(async);
        return rc;
    }

    /* Await response */
    const uvrpc_async_result_t* result = uvrpc_async_await(async);
    rc = EchoService_echo_Await(result, response);

    /* Free async context */
    uvrpc_async_free(async);

    return rc;
}


/* ==================== add Client API ==================== */

int EchoService_add_Async(
    uvrpc_client_t* client,
    const EchoService_add_Request_t* request,
    uvrpc_async_t* async
) {
    if (!client || !request || !async) {
        return UVRPC_ERROR_INVALID_PARAM;
    }

    /* Serialize request */
    uint8_t* serialized = NULL;
    size_t serialized_size = 0;
    if (EchoService_add_SerializeRequest(request, &serialized, &serialized_size) != 0) {
        return UVRPC_ERROR;
    }

    /* Send async call */
    int rc = uvrpc_client_call_async(client, "EchoService.add", "add",
                                      serialized, serialized_size, async);
    
    /* Free serialized data (uvrpc_client_call_async takes ownership) */
    if (rc != UVRPC_OK) {
        free(serialized);
    }

    return rc;
}

int EchoService_add_AsyncTimeout(
    uvrpc_client_t* client,
    const EchoService_add_Request_t* request,
    uvrpc_async_t* async,
    uint64_t timeout_ms
) {
    (void)timeout_ms; /* Timeout is handled in uvrpc_async_await_timeout */
    return EchoService_add_Async(client, request, async);
}

int EchoService_add_Await(
    const uvrpc_async_result_t* result,
    EchoService_add_Response_t* response
) {
    if (!result || !response) {
        return UVRPC_ERROR_INVALID_PARAM;
    }

    if (result->status != UVRPC_OK) {
        return result->status;
    }

    /* Deserialize response */
    if (EchoService_add_DeserializeResponse(
            result->response_data, result->response_size, response) != 0) {
        return UVRPC_ERROR;
    }

    return UVRPC_OK;
}

int EchoService_add_CallAsync(
    uvrpc_client_t* client,
    const EchoService_add_Request_t* request,
    EchoService_add_Response_t* response,
    uv_loop_t* loop
) {
    if (!client || !request || !response || !loop) {
        return UVRPC_ERROR_INVALID_PARAM;
    }

    /* Create async context */
    uvrpc_async_t* async = uvrpc_async_create(loop);
    if (!async) {
        return UVRPC_ERROR_NO_MEMORY;
    }

    /* Send async call */
    int rc = EchoService_add_Async(client, request, async);
    if (rc != UVRPC_OK) {
        uvrpc_async_free(async);
        return rc;
    }

    /* Await response */
    const uvrpc_async_result_t* result = uvrpc_async_await(async);
    rc = EchoService_add_Await(result, response);

    /* Free async context */
    uvrpc_async_free(async);

    return rc;
}


/* ==================== get_info Client API ==================== */

int EchoService_getInfo_Async(
    uvrpc_client_t* client,
    const EchoService_getInfo_Request_t* request,
    uvrpc_async_t* async
) {
    if (!client || !request || !async) {
        return UVRPC_ERROR_INVALID_PARAM;
    }

    /* Serialize request */
    uint8_t* serialized = NULL;
    size_t serialized_size = 0;
    if (EchoService_getInfo_SerializeRequest(request, &serialized, &serialized_size) != 0) {
        return UVRPC_ERROR;
    }

    /* Send async call */
    int rc = uvrpc_client_call_async(client, "EchoService.get_info", "get_info",
                                      serialized, serialized_size, async);
    
    /* Free serialized data (uvrpc_client_call_async takes ownership) */
    if (rc != UVRPC_OK) {
        free(serialized);
    }

    return rc;
}

int EchoService_getInfo_AsyncTimeout(
    uvrpc_client_t* client,
    const EchoService_getInfo_Request_t* request,
    uvrpc_async_t* async,
    uint64_t timeout_ms
) {
    (void)timeout_ms; /* Timeout is handled in uvrpc_async_await_timeout */
    return EchoService_getInfo_Async(client, request, async);
}

int EchoService_getInfo_Await(
    const uvrpc_async_result_t* result,
    EchoService_getInfo_Response_t* response
) {
    if (!result || !response) {
        return UVRPC_ERROR_INVALID_PARAM;
    }

    if (result->status != UVRPC_OK) {
        return result->status;
    }

    /* Deserialize response */
    if (EchoService_getInfo_DeserializeResponse(
            result->response_data, result->response_size, response) != 0) {
        return UVRPC_ERROR;
    }

    return UVRPC_OK;
}

int EchoService_getInfo_CallAsync(
    uvrpc_client_t* client,
    const EchoService_getInfo_Request_t* request,
    EchoService_getInfo_Response_t* response,
    uv_loop_t* loop
) {
    if (!client || !request || !response || !loop) {
        return UVRPC_ERROR_INVALID_PARAM;
    }

    /* Create async context */
    uvrpc_async_t* async = uvrpc_async_create(loop);
    if (!async) {
        return UVRPC_ERROR_NO_MEMORY;
    }

    /* Send async call */
    int rc = EchoService_getInfo_Async(client, request, async);
    if (rc != UVRPC_OK) {
        uvrpc_async_free(async);
        return rc;
    }

    /* Await response */
    const uvrpc_async_result_t* result = uvrpc_async_await(async);
    rc = EchoService_getInfo_Await(result, response);

    /* Free async context */
    uvrpc_async_free(async);

    return rc;
}

