/* Auto-generated by UVRPC DSL Generator */
#ifndef {{ namespace|upper }}_{{ service_name_upper }}_API_H
#define {{ namespace|upper }}_{{ service_name_upper }}_API_H

#include "{{ schema_basename|lower }}_builder.h"
#include "{{ schema_basename|lower }}_reader.h"
#include "{{ namespace|lower }}_{{ service_name_lower }}_rpc_common.h"
#include "../include/uvrpc.h"

#ifdef __cplusplus
extern "C" {
#endif

/* User-implemented handler function - YOU MUST IMPLEMENT THIS */
/**
 * Handle all RPC requests for {{ service.name }} service
 * 
 * @param method_name Name of the RPC method being called
 * @param request Parsed FlatBuffers request data
 * @param req UVRPC request object (for sending response)
 * @return UVRPC_OK on success, error code on failure
 * 
 * This function is called by the auto-generated RPC handler for all methods.
 * You should:
 * 1. Parse the request based on method_name using {{ namespace }}_{{ request_type }}_as_root()
 * 2. Implement your business logic
 * 3. Build response using FlatBuffers builder
 * 4. Send response using uvrpc_request_send_response()
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_handle_request(const char* method_name, 
                                       const void* request,
                                       uvrpc_request_t* req);

/* Server API functions */
/**
 * Create {{ service.name }} server
 * 
 * @param loop libuv event loop (server runs in this loop)
 * @param address Server address (e.g., "tcp://127.0.0.1:5555")
 * @return uvrpc_server_t* Server handle, or NULL on failure
 * 
 * Example:
 *   uvrpc_loop_t loop;
 *   uv_loop_init(&loop);
 *   uvrpc_server_t* server = uvrpc_{{ service_name_lower }}_create_server(&loop, "tcp://127.0.0.1:5555");
 *   if (server) {
 *       uvrpc_{{ service_name_lower }}_start_server(server);
 *       uv_run(&loop, UV_RUN_DEFAULT);
 *       uvrpc_{{ service_name_lower }}_free_server(server);
 *   }
 *   uv_loop_close(&loop);
 */
uvrpc_server_t* uvrpc_{{ service_name_lower }}_create_server(uv_loop_t* loop, 
                                                     const char* address);

/**
 * Start {{ service.name }} server
 * 
 * @param server Server handle returned by uvrpc_{{ service_name_lower }}_create_server
 * @return UVRPC_OK on success, error code on failure
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_start_server(uvrpc_server_t* server);

/**
 * Stop {{ service.name }} server
 * 
 * @param server Server handle
 */
void uvrpc_{{ service_name_lower }}_stop_server(uvrpc_server_t* server);

/**
 * Free {{ service.name }} server resources
 * 
 * @param server Server handle to free
 */
void uvrpc_{{ service_name_lower }}_free_server(uvrpc_server_t* server);

/* Client API functions */
/**
 * Create {{ service.name }} client
 * 
 * @param loop libuv event loop (client runs in this loop)
 * @param address Server address (e.g., "tcp://127.0.0.1:5555")
 * @param callback Optional connection callback (can be NULL)
 * @param ctx User context for connection callback
 * @return uvrpc_client_t* Client handle, or NULL on failure
 */
uvrpc_client_t* uvrpc_{{ service_name_lower }}_create_client(uv_loop_t* loop, 
                                                     const char* address,
                                                     uvrpc_connect_callback_t callback,
                                                     void* ctx);

/**
 * Free {{ service.name }} client resources
 * 
 * @param client Client handle to free
 */
void uvrpc_{{ service_name_lower }}_free_client(uvrpc_client_t* client);

/* Method API functions */
{% for method in service.methods -%}
/* Async callback API */
uvrpc_error_t uvrpc_{{ service_name_lower }}_{{ method.name }}(uvrpc_client_t* client,
    uvrpc_callback_t callback, void* ctx
    {%- for field in method.request_fields -%}
    {%- if field.is_array %}, const {{ field.type }}* {{ field.name }}_data, size_t {{ field.name }}_size
    {%- else %}, {{ field.type }} {{ field.name }}
    {%- endif -%}
    {%- endfor %});

/* Sync wait API (using async/await internally) */
uvrpc_error_t uvrpc_{{ service_name_lower }}_{{ method.name }}_sync(uvrpc_client_t* client,
    {{ namespace }}_{{ method.response }}_table_t* response
    {%- for field in method.request_fields -%}
    {%- if field.is_array %}, const {{ field.type }}* {{ field.name }}_data, size_t {{ field.name }}_size
    {%- else %}, {{ field.type }} {{ field.name }}
    {%- endif -%}
    {%- endfor %}
    , uint64_t timeout_ms);

{% endfor -%}

#ifdef __cplusplus
}
#endif

#endif /* {{ namespace|upper }}_{{ service_name_upper }}_API_H */