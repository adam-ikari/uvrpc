/* Auto-generated by UVRPC DSL Generator */
#ifndef {{ namespace|upper }}_{{ service_name_upper }}_API_H
#define {{ namespace|upper }}_{{ service_name_upper }}_API_H

#include "{{ schema_basename|lower }}_builder.h"
#include "{{ schema_basename|lower }}_reader.h"
#include "{{ namespace|lower }}_{{ service_name_lower }}_rpc_common.h"
#include "../include/uvrpc.h"

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================
   Broadcast Publisher API
   ============================================================ */

/**
 * Create {{ service.name }} broadcast publisher
 * 
 * @param loop libuv event loop (publisher runs in this loop)
 * @param address Publisher address (e.g., "udp://0.0.0.0:5555")
 * @return uvrpc_publisher_t* Publisher handle, or NULL on failure
 * 
 * Example:
 *   uvrpc_loop_t loop;
 *   uv_loop_init(&loop);
 *   uvrpc_publisher_t* publisher = uvrpc_{{ service_name_lower }}_create_publisher(&loop, "udp://0.0.0.0:5555");
 *   if (publisher) {
 *       uvrpc_{{ service_name_lower }}_start_publisher(publisher);
 *       // Publish messages...
 *       uvrpc_{{ service_name_lower }}_stop_publisher(publisher);
 *       uvrpc_{{ service_name_lower }}_free_publisher(publisher);
 *   }
 *   uv_loop_close(&loop);
 */
uvrpc_publisher_t* uvrpc_{{ service_name_lower }}_create_publisher(uv_loop_t* loop, 
                                                          const char* address);

/**
 * Start {{ service.name }} broadcast publisher
 * 
 * @param publisher Publisher handle returned by uvrpc_{{ service_name_lower }}_create_publisher
 * @return UVRPC_OK on success, error code on failure
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_start_publisher(uvrpc_publisher_t* publisher);

/**
 * Stop {{ service.name }} broadcast publisher
 * 
 * @param publisher Publisher handle
 */
void uvrpc_{{ service_name_lower }}_stop_publisher(uvrpc_publisher_t* publisher);

/**
 * Free {{ service.name }} broadcast publisher resources
 * 
 * @param publisher Publisher handle to free
 */
void uvrpc_{{ service_name_lower }}_free_publisher(uvrpc_publisher_t* publisher);

/* Broadcast publish functions */
{% for method in service.methods -%}
/**
 * Publish {{ method.name }} message via broadcast
 * 
 * @param publisher Publisher handle
 * @param callback Optional publish callback (can be NULL)
 * @param ctx User context for callback
{%- for field in method.request_fields -%}
 * @param {{ field.name }} {{ field.name }} parameter
{%- if field.is_array %}
 * @param {{ field.name }}_size Size of {{ field.name }} array
{%- endif -%}
{%- endfor %}
 * @return UVRPC_OK on success, error code on failure
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_{{ method.name }}(uvrpc_publisher_t* publisher,
    uvrpc_callback_t callback, void* ctx
    {%- for field in method.request_fields -%}
    {%- if field.is_array %}, const {{ field.type }}* {{ field.name }}_data, size_t {{ field.name }}_size
    {%- else %}, {{ field.type }} {{ field.name }}
    {%- endif -%}
    {%- endfor %});

{% endfor -%}

/* ============================================================
   Broadcast Subscriber API
   ============================================================ */

/**
 * Create {{ service.name }} broadcast subscriber
 * 
 * @param loop libuv event loop (subscriber runs in this loop)
 * @param address Publisher address (e.g., "udp://127.0.0.1:5555")
 * @return uvrpc_subscriber_t* Subscriber handle, or NULL on failure
 * 
 * Example:
 *   uvrpc_loop_t loop;
 *   uv_loop_init(&loop);
 *   uvrpc_subscriber_t* subscriber = uvrpc_{{ service_name_lower }}_create_subscriber(&loop, "udp://127.0.0.1:5555");
 *   if (subscriber) {
 *       uvrpc_{{ service_name_lower }}_connect_subscriber(subscriber);
 *       uvrpc_{{ service_name_lower }}_subscribe_{{ service_name_lower }}(subscriber, callback, ctx);
 *       // Run event loop...
 *       uvrpc_{{ service_name_lower }}_unsubscribe_{{ service_name_lower }}(subscriber);
 *       uvrpc_{{ service_name_lower }}_disconnect_subscriber(subscriber);
 *       uvrpc_{{ service_name_lower }}_free_subscriber(subscriber);
 *   }
 *   uv_loop_close(&loop);
 */
uvrpc_subscriber_t* uvrpc_{{ service_name_lower }}_create_subscriber(uv_loop_t* loop, 
                                                            const char* address);

/**
 * Connect {{ service.name }} broadcast subscriber to publisher
 * 
 * @param subscriber Subscriber handle returned by uvrpc_{{ service_name_lower }}_create_subscriber
 * @return UVRPC_OK on success, error code on failure
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_connect_subscriber(uvrpc_subscriber_t* subscriber);

/**
 * Disconnect {{ service.name }} broadcast subscriber
 * 
 * @param subscriber Subscriber handle
 */
void uvrpc_{{ service_name_lower }}_disconnect_subscriber(uvrpc_subscriber_t* subscriber);

/**
 * Free {{ service.name }} broadcast subscriber resources
 * 
 * @param subscriber Subscriber handle to free
 */
void uvrpc_{{ service_name_lower }}_free_subscriber(uvrpc_subscriber_t* subscriber);

/* Broadcast subscribe functions */
{% for method in service.methods -%}
/**
 * Subscribe to {{ method.name }} broadcast messages
 * 
 * @param subscriber Subscriber handle
 * @param callback Callback function to receive messages
 * @param ctx User context for callback
 * @return UVRPC_OK on success, error code on failure
 * 
 * Callback signature:
 *   void callback(const {{ namespace }}_{{ method.response }}_table_t* response, void* ctx)
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_subscribe_{{ method.name }}(uvrpc_subscriber_t* subscriber,
    void (*callback)(const {{ namespace }}_{{ method.response }}_table_t* response, void* ctx),
    void* ctx);

/**
 * Unsubscribe from {{ method.name }} broadcast messages
 * 
 * @param subscriber Subscriber handle
 * @return UVRPC_OK on success, error code on failure
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_unsubscribe_{{ method.name }}(uvrpc_subscriber_t* subscriber);

{% endfor -%}

/* Convenience: subscribe to all {{ service.name }} methods */
/**
 * Subscribe to all {{ service.name }} broadcast messages
 * 
 * @param subscriber Subscriber handle
 * @param callback Callback function to receive messages
 * @param ctx User context for callback
 * @return UVRPC_OK on success, error code on failure
 * 
 * Callback signature:
 *   void callback(const char* method_name, const void* data, size_t size, void* ctx)
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_subscribe_all(uvrpc_subscriber_t* subscriber,
    uvrpc_recv_callback_t callback,
    void* ctx);

/**
 * Unsubscribe from all {{ service.name }} broadcast messages
 * 
 * @param subscriber Subscriber handle
 * @return UVRPC_OK on success, error code on failure
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_unsubscribe_all(uvrpc_subscriber_t* subscriber);

#ifdef __cplusplus
}
#endif

#endif /* {{ namespace|upper }}_{{ service_name_upper }}_API_H */