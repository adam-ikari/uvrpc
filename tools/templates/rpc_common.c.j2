/* Auto-generated by UVRPC DSL Generator */
#include "{{ namespace|lower }}_{{ service_name_lower }}_rpc_common.h"
#include "{{ namespace|lower }}_builder.h"
#include "{{ namespace|lower }}_reader.h"
#include "../include/uvrpc.h"
#include "../include/uvrpc_async.h"

/* Async utility implementations */

{% for method in service.methods -%}

/**
 * Execute multiple {{ method.name }} calls concurrently and wait for all to complete (Promise.all)
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_{{ method.name|lower }}_all(
    uvrpc_async_ctx_t* ctx,
    uvrpc_client_t** clients,
    const {{ namespace }}_{{ method.request }}_table_t* requests,
    {{ namespace }}_{{ method.response }}_table_t*** results,
    int count,
    uint64_t timeout_ms) {
    
    if (!ctx || !clients || !requests || !results || count <= 0) {
        return UVRPC_ERROR_INVALID_PARAM;
    }
    
    /* Allocate result array */
    {{ namespace }}_{{ method.response }}_table_t* result_array = 
        calloc(count, sizeof({{ namespace }}_{{ method.response }}_table_t));
    if (!result_array) {
        return UVRPC_ERROR_NO_MEMORY;
    }
    
    /* Prepare parameters for uvrpc_async_all */
    const char** methods = calloc(count, sizeof(char*));
    const uint8_t** params_array = calloc(count, sizeof(uint8_t*));
    size_t* params_sizes = calloc(count, sizeof(size_t));
    
    if (!methods || !params_array || !params_sizes) {
        free(result_array);
        free(methods);
        free(params_array);
        free(params_sizes);
        return UVRPC_ERROR_NO_MEMORY;
    }
    
    /* Serialize all requests */
    flatcc_builder_t* builders = calloc(count, sizeof(flatcc_builder_t));
    if (!builders) {
        free(result_array);
        free(methods);
        free(params_array);
        free(params_sizes);
        return UVRPC_ERROR_NO_MEMORY;
    }
    
    for (int i = 0; i < count; i++) {
        methods[i] = "{{ method.name }}";
        flatcc_builder_init(&builders[i]);
        
        {{ namespace }}_{{ method.request }}_start_as_root(&builders[i]);
{% for field in method.request_fields -%}
        {{ namespace }}_{{ method.request }}_{{ field.name }}_add(&builders[i], {{ namespace }}_{{ method.request }}_{{ field.name }}(requests[i]));
{% endfor -%}
        {{ namespace }}_{{ method.request }}_end_as_root(&builders[i]);
        
        params_array[i] = flatcc_builder_finalize_buffer(&builders[i], &params_sizes[i]);
        if (!params_array[i]) {
            /* Cleanup and return error */
            for (int j = 0; j < i; j++) {
                flatcc_builder_reset(&builders[j]);
            }
            free(result_array);
            free(methods);
            free(params_array);
            free(params_sizes);
            free(builders);
            return UVRPC_ERROR_NO_MEMORY;
        }
    }
    
    /* Execute all calls concurrently */
    uvrpc_async_result_t** async_results = NULL;
    uvrpc_error_t ret = uvrpc_async_all(ctx, clients, methods, params_array, params_sizes,
                              &async_results, count, timeout_ms);
    
    /* Parse results */
    if (ret == UVRPC_OK && async_results) {
        for (int i = 0; i < count; i++) {
            if (async_results[i] && async_results[i]->result) {
                result_array[i] = {{ namespace }}_{{ method.response }}_as_root(async_results[i]->result);
            }
        }
    }
    
    /* Cleanup */
    for (int i = 0; i < count; i++) {
        if (params_array[i]) {
            free((void*)params_array[i]);
        }
        flatcc_builder_reset(&builders[i]);
        if (async_results && async_results[i]) {
            uvrpc_async_result_free(async_results[i]);
        }
    }
    free(result_array);
    free(methods);
    free(params_array);
    free(params_sizes);
    free(builders);
    free(async_results);
    
    *results = result_array;
    return ret;
}

/**
 * Execute multiple {{ method.name }} calls concurrently and wait for any to complete (Promise.any)
 */
uvrpc_error_t uvrpc_{{ service_name_lower }}_{{ method.name|lower }}_any(
    uvrpc_async_ctx_t* ctx,
    uvrpc_client_t** clients,
    const {{ namespace }}_{{ method.request }}_table_t* requests,
    {{ namespace }}_{{ method.response }}_table_t* result,
    int* completed_index,
    int count,
    uint64_t timeout_ms) {
    
    if (!ctx || !clients || !requests || !result || !completed_index || count <= 0) {
        return UVRPC_ERROR_INVALID_PARAM;
    }
    
    /* Prepare parameters for uvrpc_async_any */
    const char** methods = calloc(count, sizeof(char*));
    const uint8_t** params_array = calloc(count, sizeof(uint8_t*));
    size_t* params_sizes = calloc(count, sizeof(size_t));
    
    if (!methods || !params_array || !params_sizes) {
        return UVRPC_ERROR_NO_MEMORY;
    }
    
    /* Serialize all requests */
    flatcc_builder_t* builders = calloc(count, sizeof(flatcc_builder_t));
    if (!builders) {
        free(methods);
        free(params_array);
        free(params_sizes);
        return UVRPC_ERROR_NO_MEMORY;
    }
    
    for (int i = 0; i < count; i++) {
        methods[i] = "{{ method.name }}";
        flatcc_builder_init(&builders[i]);
        
        {{ namespace }}_{{ method.request }}_start_as_root(&builders[i]);
{% for field in method.request_fields -%}
        {{ namespace }}_{{ method.request }}_{{ field.name }}_add(&builders[i], {{ namespace }}_{{ method.request }}_{{ field.name }}(requests[i]));
{% endfor -%}
        {{ namespace }}_{{ method.request }}_end_as_root(&builders[i]);
        
        params_array[i] = flatcc_builder_finalize_buffer(&builders[i], &params_sizes[i]);
        if (!params_array[i]) {
            /* Cleanup and return error */
            for (int j = 0; j < i; j++) {
                flatcc_builder_reset(&builders[j]);
            }
            free(methods);
            free(params_array);
            free(params_sizes);
            free(builders);
            return UVRPC_ERROR_NO_MEMORY;
        }
    }
    
    /* Execute any call (first to complete wins) */
    uvrpc_async_result_t* async_result = NULL;
    uvrpc_error_t ret = uvrpc_async_any(ctx, clients, methods, params_array, params_sizes,
                              &async_result, completed_index, count, timeout_ms);
    
    /* Parse result */
    if (ret == UVRPC_OK && async_result && async_result->result) {
        *result = {{ namespace }}_{{ method.response }}_as_root(async_result->result);
    }
    
    /* Cleanup */
    for (int i = 0; i < count; i++) {
        if (params_array[i]) {
            free((void*)params_array[i]);
        }
        flatcc_builder_reset(&builders[i]);
    }
    if (async_result) {
        uvrpc_async_result_free(async_result);
    }
    free(methods);
    free(params_array);
    free(params_sizes);
    free(builders);
    
    return ret;
}

{% endfor -%}
{% endfor -%}