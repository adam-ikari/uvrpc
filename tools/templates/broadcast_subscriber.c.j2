/* Auto-generated by UVRPC DSL Generator */
#include "{{ namespace|lower }}_{{ service_name_lower }}_api.h"
#include <string.h>

/* ============================================================
   Broadcast Subscriber Implementation
   ============================================================ */

/* Context for method-specific callbacks */
typedef struct {
    const char* method_name;
    void (*callback)(const void* response, void* ctx);
    void* user_ctx;
} {{ service_name_lower }}_method_sub_ctx_t;

uvrpc_subscriber_t* uvrpc_{{ service_name_lower }}_create_subscriber(uv_loop_t* loop, 
                                                            const char* address) {
    /* Create configuration */
    uvrpc_config_t* config = uvrpc_config_new();
    uvrpc_config_set_loop(config, loop);
    uvrpc_config_set_address(config, address);
    uvrpc_config_set_transport(config, UVRPC_TRANSPORT_UDP);
    uvrpc_config_set_comm_type(config, UVRPC_COMM_BROADCAST);
    
    /* Create subscriber */
    uvrpc_subscriber_t* subscriber = uvrpc_subscriber_create(config);
    uvrpc_config_free(config);
    
    return subscriber;
}

uvrpc_error_t uvrpc_{{ service_name_lower }}_connect_subscriber(uvrpc_subscriber_t* subscriber) {
    return uvrpc_subscriber_connect(subscriber);
}

void uvrpc_{{ service_name_lower }}_disconnect_subscriber(uvrpc_subscriber_t* subscriber) {
    uvrpc_subscriber_disconnect(subscriber);
}

void uvrpc_{{ service_name_lower }}_free_subscriber(uvrpc_subscriber_t* subscriber) {
    uvrpc_subscriber_free(subscriber);
}

/* Internal receive callback that routes to method-specific callbacks */
static void {{ service_name_lower }}_on_broadcast_recv(const char* method_name, const uint8_t* data, size_t size, void* ctx) {
    /* Find the method-specific context and call its callback */
    /* This is a simplified implementation - in production, you'd maintain a registry */
    {{ service_name_lower }}_method_sub_ctx_t* sub_ctx = ({{ service_name_lower }}_method_sub_ctx_t*)ctx;
    
    if (sub_ctx && sub_ctx->callback) {
        /* Parse FlatBuffers data based on method name */
        {% for method in service.methods -%}
        if (strcmp(method_name, "{{ method.name }}") == 0) {
            const {{ namespace }}_{{ method.response }}_table_t* response = 
                {{ namespace }}_{{ method.response }}_as_root(data);
            sub_ctx->callback(response, sub_ctx->user_ctx);
        }
        {%- endfor %}
    }
}

/* Broadcast subscribe implementations */
{% for method in service.methods -%}

uvrpc_error_t uvrpc_{{ service_name_lower }}_subscribe_{{ method.name }}(uvrpc_subscriber_t* subscriber,
    void (*callback)(const {{ namespace }}_{{ method.response }}_table_t* response, void* ctx),
    void* ctx) {
    
    /* Create subscription context */
    {{ service_name_lower }}_method_sub_ctx_t* sub_ctx = ({{ service_name_lower }}_method_sub_ctx_t*)uvrpc_alloc(sizeof({{ service_name_lower }}_method_sub_ctx_t));
    sub_ctx->method_name = "{{ method.name }}";
    sub_ctx->callback = callback;
    sub_ctx->user_ctx = ctx;
    
    /* Subscribe to method */
    uvrpc_error_t err = uvrpc_subscriber_subscribe(subscriber, "{{ method.name }}", 
        (uvrpc_recv_callback_t){{ service_name_lower }}_on_broadcast_recv, sub_ctx);
    
    if (err != UVRPC_OK) {
        uvrpc_free(sub_ctx);
    }
    
    return err;
}

uvrpc_error_t uvrpc_{{ service_name_lower }}_unsubscribe_{{ method.name }}(uvrpc_subscriber_t* subscriber) {
    return uvrpc_subscriber_unsubscribe(subscriber, "{{ method.name }}");
}

{% endfor -%}

/* Convenience functions */
uvrpc_error_t uvrpc_{{ service_name_lower }}_subscribe_all(uvrpc_subscriber_t* subscriber,
    uvrpc_recv_callback_t callback,
    void* ctx) {
    
    /* Subscribe to all methods */
    {% for method in service.methods -%}
    {
        uvrpc_error_t err = uvrpc_subscriber_subscribe(subscriber, "{{ method.name }}", callback, ctx);
        if (err != UVRPC_OK) {
            return err;
        }
    }
    {%- endfor %}
    
    return UVRPC_OK;
}

uvrpc_error_t uvrpc_{{ service_name_lower }}_unsubscribe_all(uvrpc_subscriber_t* subscriber) {
    
    /* Unsubscribe from all methods */
    {% for method in service.methods -%}
    uvrpc_subscriber_unsubscribe(subscriber, "{{ method.name }}");
    {%- endfor %}
    
    return UVRPC_OK;
}