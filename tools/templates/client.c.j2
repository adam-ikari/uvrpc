/* Auto-generated by UVRPC DSL Generator */
#include "{{ schema_basename|lower }}_builder.h"
#include "{{ schema_basename|lower }}_reader.h"
#include "{{ namespace|lower }}_{{ service_name_lower }}_api.h"
#include "../include/uvrpc.h"
#include "../include/uvrpc_async.h"

/* Client connection helper function */
/**
 * Create {{ service.name }} client
 * 
 * IMPORTANT: This function initiates an asynchronous connection.
 * The connection process runs in the event loop and will complete
 * asynchronously. You must run the event loop to establish the connection.
 * 
 * @param loop libuv event loop
 * @param address Server address (e.g., "tcp://127.0.0.1:5555")
 * @param callback Optional connection callback (called when connection completes)
 * @param ctx User context for connection callback
 * @return uvrpc_client_t* Client handle, or NULL on failure
 * 
 * Usage example:
 *   uvrpc_client_t* client = uvrpc_{{ service_name_lower }}_create_client(&loop, "tcp://127.0.0.1:5555", on_connect, NULL);
 *   if (client) {
 *       // Run event loop to establish connection
 *       uv_run(&loop, UV_RUN_DEFAULT);
 *       uvrpc_{{ service_name_lower }}_free_client(client);
 *   }
 */
uvrpc_client_t* uvrpc_{{ service_name_lower }}_create_client(uv_loop_t* loop, 
                                                     const char* address,
                                                     uvrpc_connect_callback_t callback,
                                                     void* ctx) {
    /* Create configuration */
    uvrpc_config_t* config = uvrpc_config_new();
    if (!config) {
        return NULL;
    }
    
    uvrpc_config_set_loop(config, loop);
    uvrpc_config_set_address(config, address);
    uvrpc_config_set_comm_type(config, UVRPC_COMM_SERVER_CLIENT);
    
    /* Create client */
    uvrpc_client_t* client = uvrpc_client_create(config);
    if (!client) {
        uvrpc_config_free(config);
        return NULL;
    }
    
    /* Initiate asynchronous connection */
    int ret;
    if (callback) {
        /* User provided callback - use it */
        ret = uvrpc_client_connect_with_callback(client, callback, ctx);
    } else {
        /* No callback - connection will complete silently */
        ret = uvrpc_client_connect(client);
    }
    
    if (ret != UVRPC_OK) {
        uvrpc_client_free(client);
        uvrpc_config_free(config);
        return NULL;
    }
    
    uvrpc_config_free(config);
    return client;
}

/**
 * Free {{ service.name }} client resources
 * 
 * @param client Client handle to free
 */
void uvrpc_{{ service_name_lower }}_free_client(uvrpc_client_t* client) {
    if (client) {
        uvrpc_client_free(client);
    }
}

/* {{ service.name }} Client API */

{% for method in service.methods -%}
/* Async callback API */
uvrpc_error_t uvrpc_{{ service_name_lower }}_{{ method.name }}(uvrpc_client_t* client,
    uvrpc_callback_t callback, void* ctx
    {%- for field in method.request_fields -%}
    {%- if field.is_array %}, const {{ field.type }}* {{ field.name }}_data, size_t {{ field.name }}_size
    {%- else %}, {{ field.type }} {{ field.name }}
    {%- endif -%}
    {%- endfor %}) {
    
    /* Validate parameters */
    if (!client) {
        return UVRPC_ERROR_INVALID_PARAM;
    }
    
    /* Serialize request using FlatBuffers */
    flatcc_builder_t builder;
    flatcc_builder_init(&builder);
    
    /* Serialize request fields */
    {{ namespace }}_{{ method.request }}_start_as_root(&builder);
{% for field in method.request_fields -%}
{% if field.is_array -%}
    /* Array field: {{ field.name }} */
    if ({{ field.name }}_data && {{ field.name }}_size > 0) {
        flatbuffers_vec_ref_t {{ field.name }}_ref = flatbuffers_uint8_vec_create(&builder, {{ field.name }}_data, {{ field.name }}_size);
        {{ namespace }}_{{ method.request }}_{{ field.name }}_add(&builder, {{ field.name }}_ref);
    }
{% else -%}
    {{ namespace }}_{{ method.request }}_{{ field.name }}_add(&builder, {{ field.name }});
{% endif -%}
{% endfor -%}
    {{ namespace }}_{{ method.request }}_end_as_root(&builder);
    
    size_t size;
    void* buf = flatcc_builder_finalize_buffer(&builder, &size);
    
    if (!buf) {
        flatcc_builder_clear(&builder);
        return UVRPC_ERROR_NO_MEMORY;
    }
    
    /* Send request using core API (retry logic is in uvrpc_client_call) */
    uvrpc_error_t ret = uvrpc_client_call(client, "{{ method.name }}", buf, size, callback, ctx);
    
    /* Free the buffer allocated by flatcc_builder_finalize_buffer */
    free(buf);
    flatcc_builder_clear(&builder);
    return ret;
}

/* Sync wait API (using async/await internally) */
typedef struct {
    {{ namespace }}_{{ method.response }}_table_t response;
    int completed;
    uvrpc_error_t status;
} sync_{{ service_name_lower }}_{{ method.name }}_ctx_t;

static void sync_{{ service_name_lower }}_{{ method.name }}_callback(uvrpc_response_t* resp, void* ctx) {
    sync_{{ service_name_lower }}_{{ method.name }}_ctx_t* sync_ctx = (sync_{{ service_name_lower }}_{{ method.name }}_ctx_t*)ctx;
    sync_ctx->status = resp->status;
    
    if (resp->status == UVRPC_OK && resp->result && resp->result_size > 0) {
        /* Parse response table */
        sync_ctx->response = {{ namespace }}_{{ method.response }}_as_root(resp->result);
    }
    
    sync_ctx->completed = 1;
}

uvrpc_error_t uvrpc_{{ service_name_lower }}_{{ method.name }}_sync(uvrpc_client_t* client,
    {{ namespace }}_{{ method.response }}_table_t* response
    {%- for field in method.request_fields -%}
    {%- if field.is_array %}, const {{ field.type }}* {{ field.name }}_data, size_t {{ field.name }}_size
    {%- else %}, {{ field.type }} {{ field.name }}
    {%- endif -%}
    {%- endfor %}
    , uint64_t timeout_ms) {
    
    /* Validate parameters */
    if (!client || !response) {
        return UVRPC_ERROR_INVALID_PARAM;
    }
    
    /* Create async context */
    uv_loop_t* loop = uvrpc_client_get_loop(client);
    uvrpc_async_ctx_t* async_ctx = uvrpc_async_ctx_new(loop);
    if (!async_ctx) {
        return UVRPC_ERROR_NO_MEMORY;
    }
    
    /* Create sync context */
    sync_{{ service_name_lower }}_{{ method.name }}_ctx_t sync_ctx = {
        .completed = 0,
        .status = UVRPC_OK
    };
    
    /* Serialize request */
    flatcc_builder_t builder;
    flatcc_builder_init(&builder);
    
    {{ namespace }}_{{ method.request }}_start_as_root(&builder);
{% for field in method.request_fields -%}
{% if field.is_array -%}
    /* Array field: {{ field.name }} */
    if ({{ field.name }}_data && {{ field.name }}_size > 0) {
        flatbuffers_vec_ref_t {{ field.name }}_ref = flatbuffers_uint8_vec_create(&builder, {{ field.name }}_data, {{ field.name }}_size);
        {{ namespace }}_{{ method.request }}_{{ field.name }}_add(&builder, {{ field.name }}_ref);
    }
{% else -%}
    {{ namespace }}_{{ method.request }}_{{ field.name }}_add(&builder, {{ field.name }});
{% endif -%}
{% endfor -%}
    {{ namespace }}_{{ method.request }}_end_as_root(&builder);
    
    size_t size;
    void* buf = flatcc_builder_finalize_buffer(&builder, &size);
    
    if (!buf) {
        flatcc_builder_clear(&builder);
        uvrpc_async_ctx_free(async_ctx);
        return UVRPC_ERROR_NO_MEMORY;
    }
    
    /* Send async request */
    uvrpc_error_t ret = uvrpc_client_call(client, "{{ method.name }}", buf, size, 
                                 sync_{{ service_name_lower }}_{{ method.name }}_callback, &sync_ctx);
    
    /* Free the buffer allocated by flatcc_builder_finalize_buffer */
    free(buf);
    flatcc_builder_clear(&builder);
    
    if (ret != UVRPC_OK) {
        uvrpc_async_ctx_free(async_ctx);
        return ret;
    }
    
    /* Wait for completion using async/await */
    uvrpc_async_result_t* async_result = NULL;
    ret = uvrpc_async_timeout(async_ctx, client, "{{ method.name }}", 
                               NULL, 0, &async_result, timeout_ms);
    
    uvrpc_async_ctx_free(async_ctx);
    
    if (ret != UVRPC_OK) {
        return ret;
    }
    
    /* Check sync context */
    if (!sync_ctx.completed) {
        if (async_result) uvrpc_async_result_free(async_result);
        return UVRPC_ERROR_TIMEOUT;
    }
    
    /* Copy response to output */
    *response = sync_ctx.response;
    
    if (async_result) uvrpc_async_result_free(async_result);
    
    return sync_ctx.status;
}

{% endfor -%}